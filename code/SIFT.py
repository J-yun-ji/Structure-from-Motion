# -*- coding: utf-8 -*-
"""SIFT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JPWAu65ovJBYrgHjB55CUeSpjYslHtRu
"""

# This mounts your Google Drive to the Colab VM.
from google.colab import drive
drive.mount('/content/drive')

'''FOLDERNAME = 'OpenCV'''

# Commented out IPython magic to ensure Python compatibility.
FOLDERNAME = 'OpenCV'
assert FOLDERNAME is not None, "[!] Enter the foldername."

import sys
sys.path.append('/content/drive/MyDrive/{}'.format(FOLDERNAME))

# Change dariectory to current folder
# %cd /content/drive/MyDrive/$FOLDERNAME

# keypoints test
'''for kp in keypoints:
    num += 1
    print("Keypoint ", num, ":")  # keypoint의 응답 값 출력
    print("Position : ", kp.pt)  # keypoint의 위치 출력
    print("Scale : ", kp.size)  # keypoint의 크기 출력
    print("Orientation : ", kp.angle)  # keypoint의 방향 출력
    print()'''

# -------------------------------------------

import numpy as np
import cv2 as cv
from google.colab.patches import cv_imshow

import torch
'''
img_files = []
keypoints_img_files = []
keypoints_scales = []
keypoints_orientation = []

for i in range(32):
    img_files.append('{:04d}.JPG'.format(i))

for num in range(32):
    img = cv.imread(img_files[num])
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    sift = cv.SIFT_create()
    keypoints = sift.detect(gray, None)
    img = cv.drawKeypoints(gray,keypoints,img)


    keypoints_img_files.append('keypoints_{:02d}.jpg'.format(num))
    cv.imwrite(keypoints_img_files[num], img)

    # keypoint의 size(scale), angle(orientation) 저장
    keypoints_scales.append([kp.size for kp in keypoints])
    keypoints_orientation.append([kp.angle for kp in keypoints])

# keypoints_scales 원소 중 가장 길이가 긴 값 찾기
max_length = max(len(scale) for scale in keypoints_scales)

# 패딩 맞추기
scale_padding = [scale + [0] * (max_length - len(scale)) for scale in keypoints_scales]
orientation_padding = [orientation + [0] * (max_length - len(orientation)) for orientation in keypoints_orientation]

# scale, orientation를 파이토치 텐서로 변환
scales_tensor = torch.tensor(scale_padding)
orientations_tensor = torch.tensor(orientation_padding)

# 3차원 배열 생성
keypoints_3d = torch.stack((scales_tensor, orientations_tensor), dim=1)

# 결과 출력
print(keypoints_3d.size())'''

#keypoints_3d

# color, rotate, resize
imgtest = cv.imread('0000.JPG')
colortest = cv.cvtColor(imgtest, cv.COLOR_BGR2XYZ)
cv_imshow(colortest)

# 시계방향으로 90도 회전
rotatetest = cv.rotate(imgtest, cv.ROTATE_90_CLOCKWISE)
#cv_imshow(rotatetest)

# image size 조절
resizetest = cv.resize(imgtest, dsize=(640, 480), interpolation=cv.INTER_AREA)
#cv_imshow(resizetest) 1944x1296

imgpix = cv.imread("0000.JPG")

# pixel 전체 크기
print('size info : ', imgpix.shape)
print('height : ', imgpix.shape[0])

# pixel 타입 정보
print(type(imgpix))
print(len(imgpix), '\n\n')

# RGB pixel 값 추출 -> BGR 순서.
imgpix

print('BGR of (100, 100) Pixel: ', imgpix[100,100])
print('Blue of (100, 100) Pixel: ', imgpix[100,100, 0])
print('Green of (100, 100) Pixel: ', imgpix[100,100, 1])
print('Red of (100, 100) Pixel: ', imgpix[100,100, 2])
print('Red of (100, 100) Pixel: ', imgpix[[0, 0, 100]])

# B, G 값 0으로 만들고 R 값만 추출.
img_red = cv.imread("0000.JPG")

# B 배열 벡터 값 모두 0으로 변환
img_red[:, :, 0] = 0
# G 배열 벡터 값 모두 0으로 변환
img_red[:, :, 1] = 0

cv_imshow(img_red)
img_red

# print(keypoints_3d.shape)
# print(img_red.shape)

import matplotlib.pyplot as plt

# 0000.JPG의 R 200번째 행 그래프
plt.plot(img_red[200], 'o-', color='cadetblue', ms=3, mfc='purple', mec='purple')

# 범위 설정
plt.ylim([115, 180])
plt.show()

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# 이미지 파일 불러오기
img_red = cv.imread("0000.JPG")

# B 배열 벡터 값 모두 0으로 변환
img_red[:, :, 0] = 0
# G 배열 벡터 값 모두 0으로 변환
img_red[:, :, 1] = 0

# R 채널 데이터 추출
r_channel = img_red[200, :, 2]

# LMS 알고리즘을 위한 비용 함수 정의
def cost_function(params, x, y):
    a, b = params
    y_pred = a * x + b
    error = np.mean((y_pred - y) ** 2)
    return error

# LMS 알고리즘 적용
result = minimize(cost_function, [1, 1], args=(np.arange(len(r_channel)), r_channel))

# 최적화된 파라미터 값 얻기
a_opt, b_opt = result.x

# 최적화된 선 그리기
plt.plot(r_channel, 'o-', color='cadetblue', ms=3, mfc='purple', mec='purple')
plt.plot(a_opt * np.arange(len(r_channel)) + b_opt, color='red', label='Optimized Line')
plt.ylim([115, 180])
plt.legend()
plt.show()
